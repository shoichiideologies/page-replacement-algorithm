<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
		<title>Electron boilerplate</title>
		<link rel="stylesheet" href="information.css">
    </head>
    <body>
        <div id="container">
            <nav>
                <section>
                    <p onclick="location.href='index.html'">Computation</p>
                    <p onclick="location.href='information.html'">Information</p>
                </section>
            </nav>
            <header>
                <section>
                    <h1>Page-Replacement Algorithms</h1>
                    <p>In modern computing, efficient memory management is critical for performance. One important technique is demand paging, where only the necessary parts of a program are loaded into memory as needed. However, when memory becomes full, the operating system must decide which page to remove to make space for a new one. This decision is made using page-replacement algorithms.
                    Among the various algorithms, three are especially important: First-In, First-Out (FIFO), Optimal Page Replacement (OPT), and Least Recently Used (LRU).
                    </p>
                </section>
            </header>
            <main>
                <section class="algorithm">
                    <h2>First-In-First-Out (FIFO) Algorithm</h2>
                    <p class="definition">
                      First-In, First-Out (FIFO) is the simplest page-replacement algorithm. It replaces the oldest page in memory—the one that was loaded first—whenever a new page needs to be brought in. FIFO treats pages like a queue: pages are added at the end and removed from the front. While easy to implement and understand, FIFO can perform poorly because it may evict frequently used pages. Moreover, FIFO suffers from Belady’s anomaly, where adding more memory could paradoxically increase the number of page faults instead of reducing them.
                    </p>
                    <p class="complexity">Time complexity: O(n) per operation (naïve), O(1) with hash for lookup + queue</p>
                    <p class="complexity">Space complexity: O(n)</p>
                  </section>
                  
                  <section class="algorithm">
                    <h2>Last Recently Used (LRU) Algorithm</h2>
                    <p class="definition">
                      Least Recently Used (LRU) is a practical algorithm that approximates the optimal strategy without requiring future knowledge. It replaces the page that has not been accessed for the longest time, based on the assumption that pages recently used are more likely to be used again soon. LRU performs very well in real-world applications that exhibit temporal locality—where programs tend to access the same pages repeatedly. Although LRU provides excellent results and avoids Belady’s anomaly, it requires additional mechanisms (like counters, stacks, or reference bits) to track page usage, which can introduce overhead depending on the system’s hardware support.
                    </p>
                    <p class="complexity">Time complexity: O(n) (naïve), O(1) optimized with HashMap + Doubly Linked List</p>
                    <p class="complexity">Space complexity: O(n) frames + O(n) recency metadata</p>
                  </section>
                  
                  <section class="algorithm">
                    <h2>Optimal (OPT) Algorithm</h2>
                    <p class="definition">
                      Optimal Page Replacement (OPT) is a theoretical algorithm that always replaces the page that will not be used for the longest time in the future. By making perfect choices based on future knowledge, OPT guarantees the fewest possible page faults for any reference string and memory size. While OPT serves as an important benchmark for evaluating other algorithms, it cannot be implemented in practice because no system can predict future memory accesses. Therefore, OPT is mainly used in simulations and theoretical analyses to measure how close real algorithms come to the ideal performance.
                    </p>
                    <p class="complexity">Time complexity: O(n) per replacement (scan future)</p>
                    <p class="complexity">Space complexity: Requires full future knowledge — only usable for benchmarking</p>
                  </section>
            </main>
            <footer>
                <p>Computer Science final project in Operating System by Angelo Miranda</p>
                <a href="https://github.com/shoichiideologies" target="_blank" rel="noopener">shoichiideologies/Github</a>
            </footer>
            <script src="./information.js"></script>
        </div>
    </body>
</html>